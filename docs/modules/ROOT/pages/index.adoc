= Quarkus FluentJdbc

include::./includes/attributes.adoc[]

This extension integrates FluentJdbc with Quarkus by making use of Agroal as the connectionpool implementation.

Furthermore, it adds the following enhancements to it:

- a `RecordMapper` class which can be used to map query results into Java Records,
- a `JsonObjectMapper` which can be used to map queries into the `JsonObject` that comes with Quarkus.

== Installation

If you want to use this extension, you need to add the `io.quarkiverse.fluentjdbc:quarkus-fluentjdbc` extension first to your build file.

For instance, with Maven, add the following dependency to your POM file:

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>io.quarkiverse.fluentjdbc</groupId>
    <artifactId>quarkus-fluentjdbc</artifactId>
    <version>{project-version}</version>
</dependency>
----

== Usage

Define your datasource:

[source,properties,subs=attributes+]
----
quarkus.datasource.db-kind=postgresql
%prod.quarkus.datasource.jdbc.url=jdbc://postgresql://your-pg-cluster:5432
%prod.quarkus.datasource.jdbc.username=username
%prod.quarkus.datasource.jdbc.password=password

quarkus.datasource.devservices.port=5431
----

The above configuration will also start Dev services with a PosgtreSql database on port 5431.

Now you can use FluentJdbc as follows:

[source,java,subs=attributes+]
----
import io.quarkiverse.fluentjdbc.runtime.RecordMapper;

@Path("/fruits")
public class FruitResource {

    static final RecordMapper fruitMapper = new RecordMapper(Fruit.class);

    @Inject
    FluentJdbc jdbc;

    @GET
    public List<Fruit> findAll(@RestQuery @DefaultValue("0") int start, @RestQuery @Min(1) @Max(200) @DefaultValue("50") int size) {
        return this.jdbc.query()
                .select("select * from fruit where id > ? order by id")
                .params(start)
                .maxRows(size)
                .listResult(fruitMapper);
    }
}
----

Define the Fruit DTO:

[source,java,subs=attributes+]
----
public record Fruit(
        int id,
        String name,
        String type,
        BigDecimal calories,
        BigDecimal carbohydrates,
        BigDecimal fiber,
        BigDecimal sugars,
        BigDecimal fat,
        BigDecimal protein
) {
}
----

You can also select only the columns that are defined in the Fruit record:

[source,java,subs=attributes+]
----
import io.quarkiverse.fluentjdbc.runtime.RecordMapper;

@Path("/fruits")
public class FruitResource {

    static final RecordMapper fruitMapper = new RecordMapper(Fruit.class);

    @Inject
    FluentJdbc jdbc;

    @GET
    public List<Fruit> findAll(@RestQuery @DefaultValue("0") int start, @RestQuery @Min(1) @Max(200) @DefaultValue("50") int size) {
        return this.jdbc.query()
                .select("select %s from fruit where id > ? order by id".formatted(fruitMapper.columnNames()))
                .params(start)
                .maxRows(size)
                .listResult(fruitMapper);
    }
}
----

If you don't use Java Records, but POJO's instead then you can use the `ObjectMappers` that comes with FluentJdbc:

[source,java,subs=attributes+]
----
import org.codejargon.fluentjdbc.api.mapper.ObjectMappers;

@Path("/fruits")
public class FruitResource {

    @Inject
    ObjectMappers objectMappers;

    @Inject
    FluentJdbc jdbc;

    @GET
    public List<MyFruit> findAll(@RestQuery @DefaultValue("0") int start, @RestQuery @Min(1) @Max(200) @DefaultValue("50") int size) {
        return this.jdbc.query()
                .select("select * from fruit where id > ? order by id")
                .params(start)
                .maxRows(size)
                .listResult(this.objectMappers.forClass(MyFruit.class));
    }
}
----

For more examples, see links below.
-

[[extension-configuration-reference]]
== Extension Configuration Reference

include::includes/quarkus-fluentjdbc.adoc[leveloffset=+1, opts=optional]

=== Configuring SqlErrorHandler, ObjectMappers, ParamSetters & AfterQueryListener

The easiest way to configure these are by exposing them as CDI beans:

[source,java,subs=attributes+]
----

    @Produces
    @Singleton
    @Unremovable
    public SqlErrorHandler errorHandler() {
        return (err, query) -> {
            Log.errorf("Error occured while executing query: %s, state: %s, code: %s",
                    query.orElse("no query found"),
                    err.getSQLState(),
                    err.getErrorCode());

            if (err.getErrorCode() == 123) {
                return SqlErrorHandler.Action.RETRY;
            }
            throw err;
        };
    }

    @Produces
    @Singleton
    @Unremovable
    public AfterQueryListener queryListener() {
        return execution -> {
            if (execution.success()) {
                Log.debugf("Query took %s ms to execute: %s",
                        execution.executionTimeMs(),
                        execution.sql()
                );
            }
        };
    }

    @Produces
    @Singleton
    public ObjectMappers objectMappers() {
        return ObjectMappers.builder().build();
    }

    @Produces
    @Singleton
    @Unremovable
    public ParamSetter<UUID> uuidParamSetter() {
        return (uuid, prepStmt, i) -> prepStmt.setString(i, uuid.toString());
    }

    @Produces
    @Singleton
    @Unremovable
    public ParamSetter<MyOtherType> otherParamSetter() {
        return (other, prepStmt, i) -> prepStmt.setString(i, other.toString());
    }
----

-- More information:

- [Official FluentJdbc documenation](https://zsoltherpai.github.io/fluent-jdbc)
- [More Examples](https://github.com/Serkan80/quarkus-fluentjdbc-extension/tree/master/examples)

